// XRP Network Configuration
export const NETWORKS = {
  MAINNET: {
    name: 'Mainnet',
    server: 'wss://xrplcluster.com',
    explorer: 'https://livenet.xrpl.org',
    isLive: true
  },
  TESTNET: {
    name: 'Testnet',
    server: 'wss://s.altnet.rippletest.net:51233',
    explorer: 'https://testnet.xrpl.org',
    isLive: false
  }
};

let currentNetwork = NETWORKS.TESTNET; // Default to testnet for safety

export const setNetwork = (network) => {
  currentNetwork = network;
  console.log(`Network switched to: ${network.name}`);
};

export const getCurrentNetwork = () => currentNetwork;

export const getBalance = async (address) => {
  try {
    const xrpl = await import('xrpl');
    const client = new xrpl.Client(currentNetwork.server);
    await client.connect();
    
    const response = await client.request({
      command: "account_info",
      account: address,
      ledger_index: "validated"
    });
    
    await client.disconnect();
    
    const drops = response.result.account_data.Balance;
    return parseFloat(drops) / 1000000;
  } catch (error) {
    console.error("Error fetching balance:", error);
    
    if (error.message && error.message.includes('actNotFound')) {
      return 0;
    }
    
    throw error;
  }
};

export const sendXRP = async (secret, recipient, amount, destinationTag = null) => {
  try {
    const xrpl = await import('xrpl');
    const client = new xrpl.Client(currentNetwork.server);
    await client.connect();

    const wallet = xrpl.Wallet.fromSeed(secret);
    
    const amountDrops = (amount * 1000000).toString();

    const transaction = {
      TransactionType: "Payment",
      Account: wallet.address,
      Amount: amountDrops,
      Destination: recipient,
      ...(destinationTag && { DestinationTag: destinationTag }),
    };

    const prepared = await client.autofill(transaction);
    const signed = wallet.sign(prepared);
    
    const result = await client.submitAndWait(signed.tx_blob);

    await client.disconnect();
    return result;
  } catch (error) {
    console.error("Transaction Error Details:", error);
    throw error;
  }
};

export const isValidAddress = (address) => {
  if (!address || typeof address !== 'string') return false;
  
  if (!address.startsWith('r') || address.length < 25 || address.length > 35) {
    return false;
  }
  
  const base58Regex = /^[1-9A-HJ-NP-Za-km-z]+$/;
  return base58Regex.test(address);
};

export const getTransactionHistory = async (address, limit = 20) => {
  try {
    const xrpl = await import('xrpl');
    const client = new xrpl.Client(currentNetwork.server);
    await client.connect();

    const response = await client.request({
      command: "account_tx",
      account: address,
      limit: limit
    });

    await client.disconnect();
    return response.result.transactions || [];
  } catch (error) {
    console.error("Error fetching transaction history:", error);
    return [];
  }
};

// Get current XRP price in USD
export const getXRPPrice = async () => {
  try {
    const response = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
    const data = await response.json();
    return data.ripple.usd;
  } catch (error) {
    console.error("Error fetching XRP price:", error);
    return null;
  }
};

// Validate and parse destination tag
export const validateDestinationTag = (tag) => {
  if (!tag || tag === '') return null;
  const parsed = parseInt(tag);
  return (parsed >= 0 && parsed <= 4294967295) ? parsed : null;
};

// Format XRP amount
export const formatXRP = (amount) => {
  if (!amount || isNaN(amount)) return '0.000000';
  return parseFloat(amount).toFixed(6);
};

// Get account info (including reserves, flags, etc.)
export const getAccountInfo = async (address) => {
  try {
    const xrpl = await import('xrpl');
    const client = new xrpl.Client(currentNetwork.server);
    await client.connect();
    
    const response = await client.request({
      command: "account_info",
      account: address,
      ledger_index: "validated"
    });
    
    await client.disconnect();
    return response.result.account_data;
  } catch (error) {
    console.error("Error fetching account info:", error);
    throw error;
  }
};
