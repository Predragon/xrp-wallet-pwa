import { Client, Wallet, dropsToXrp, xrpToDrops } from 'xrpl';

// Network configurations
export const NETWORKS = {
  TESTNET: { 
    url: 'wss://s.altnet.rippletest.net:51233', 
    isLive: false,
    name: 'Testnet'
  },
  MAINNET: { 
    url: 'wss://xrplcluster.com/', 
    isLive: true,
    name: 'Mainnet'
  }
};

let currentNetwork = NETWORKS.TESTNET;
let client = null;

// Initialize client connection
const getClient = async () => {
  if (!client || !client.isConnected()) {
    client = new Client(currentNetwork.url);
    await client.connect();
  }
  return client;
};

// Set network and reconnect
export const setNetwork = async (network) => {
  if (client && client.isConnected()) {
    await client.disconnect();
  }
  currentNetwork = network;
  client = null; // Force reconnection on next use
};

export const getCurrentNetwork = () => currentNetwork;

// Generate a new wallet
export const generateWallet = () => {
  const wallet = Wallet.generate();
  return {
    address: wallet.address,
    secret: wallet.seed,
    publicKey: wallet.publicKey,
    privateKey: wallet.privateKey
  };
};

// Import wallet from secret
export const importWallet = (secret) => {
  try {
    const wallet = Wallet.fromSeed(secret);
    return {
      address: wallet.address,
      secret: wallet.seed,
      publicKey: wallet.publicKey,
      privateKey: wallet.privateKey
    };
  } catch (error) {
    throw new Error('Invalid secret key');
  }
};

// Get account balance
export const getBalance = async (address) => {
  try {
    const cli = await getClient();
    const response = await cli.request({
      command: 'account_info',
      account: address,
      ledger_index: 'validated'
    });
    
    const balance = dropsToXrp(response.result.account_data.Balance);
    return parseFloat(balance);
  } catch (error) {
    if (error.data?.error === 'actNotFound') {
      return 0; // Account not yet funded
    }
    throw error;
  }
};

// Send XRP transaction
export const sendXRP = async (secret, recipient, amount, destinationTag = null) => {
  try {
    const cli = await getClient();
    const wallet = Wallet.fromSeed(secret);
    
    const payment = {
      TransactionType: 'Payment',
      Account: wallet.address,
      Amount: xrpToDrops(amount),
      Destination: recipient
    };

    if (destinationTag !== null && destinationTag !== undefined) {
      payment.DestinationTag = parseInt(destinationTag);
    }

    const prepared = await cli.autofill(payment);
    const signed = wallet.sign(prepared);
    const result = await cli.submitAndWait(signed.tx_blob);

    if (result.result.meta.TransactionResult === 'tesSUCCESS') {
      return {
        hash: result.result.hash,
        validated: true,
        result: result.result.meta.TransactionResult
      };
    } else {
      throw new Error(`Transaction failed: ${result.result.meta.TransactionResult}`);
    }
  } catch (error) {
    console.error('Send XRP error:', error);
    throw new Error(error.message || 'Transaction failed');
  }
};

// Validate XRP address
export const isValidAddress = (address) => {
  try {
    if (!address || typeof address !== 'string') return false;
    
    // Basic validation
    if (!address.startsWith('r')) return false;
    if (address.length < 25 || address.length > 35) return false;
    
    // Use XRPL's built-in validation if available
    // For now, basic check is sufficient
    return true;
  } catch {
    return false;
  }
};

// Get transaction history
export const getTransactionHistory = async (address, limit = 20) => {
  try {
    const cli = await getClient();
    const response = await cli.request({
      command: 'account_tx',
      account: address,
      ledger_index_min: -1,
      ledger_index_max: -1,
      limit: limit
    });

    const rawTxs = response.result.transactions || [];

    return rawTxs.map(txItem => {
      const tx = txItem.tx;
      const meta = txItem.meta;

      if (!tx) return null;

      let amount = 0;
      let currency = '';

      let isSent = tx.Account === address;
      let isReceived = false;

      if (tx.TransactionType === 'Payment') {
        isReceived = tx.Destination === address;

        if (typeof tx.Amount === 'string') {
          amount = dropsToXrp(tx.Amount);
          currency = 'XRP';
        } else if (tx.Amount && tx.Amount.value && tx.Amount.currency) {
          amount = parseFloat(tx.Amount.value);
          currency = tx.Amount.currency;
        }
      } else if (tx.TransactionType === 'OfferCreate') {
        // Basic handling for OfferCreate - you may want to expand this
        if (meta.delivered_amount) {
          if (typeof meta.delivered_amount === 'string') {
            amount = dropsToXrp(meta.delivered_amount);
            currency = 'XRP';
          } else {
            amount = parseFloat(meta.delivered_amount.value);
            currency = meta.delivered_amount.currency;
          }
        }
        isSent = true; // Typically sent by the account
        isReceived = false;
      }

      return {
        txHash: tx.hash,
        txType: tx.TransactionType,
        isSent,
        isReceived,
        amount,
        currency,
        date: new Date((tx.date + 946684800) * 1000).toLocaleString(),
        destinationTag: tx.DestinationTag,
        isSuccess: meta.TransactionResult === 'tesSUCCESS'
      };
    }).filter(Boolean);
  } catch (error) {
    if (error.data?.error === 'actNotFound') {
      return []; // No transactions yet
    }
    console.error('Transaction history error:', error);
    return [];
  }
};

// Get XRP price from CoinGecko
export const getXRPPrice = async () => {
  try {
    const response = await fetch(
      'https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd'
    );
    const data = await response.json();
    return data.ripple?.usd || 0;
  } catch (error) {
    console.error('Price fetch error:', error);
    return 0;
  }
};

// Fund testnet account (for testnet only)
export const fundTestnetAccount = async (address) => {
  if (currentNetwork.isLive) {
    throw new Error('Cannot fund mainnet accounts via faucet');
  }

  try {
    const cli = await getClient();
    const response = await cli.fundWallet(null, {
      faucetHost: 'faucet.altnet.rippletest.net',
      amount: '1000' // 1000 XRP on testnet
    });
    
    return response;
  } catch (error) {
    console.error('Faucet error:', error);
    throw new Error('Failed to fund account. Please use the web faucet.');
  }
};

// Cleanup connection
export const disconnect = async () => {
  if (client && client.isConnected()) {
    await client.disconnect();
    client = null;
  }
};

// Secure storage functions (localStorage with basic encryption)
const STORAGE_PREFIX = 'xrp_wallet_';
const WALLETS_KEY = 'xrp_wallet_list';

export const saveWallet = (wallet, password) => {
  try {
    // Simple encryption (for production, use proper encryption library)
    const data = JSON.stringify({ wallet, timestamp: Date.now() });
    const encoded = btoa(data + password); // Basic obfuscation
    
    localStorage.setItem(`${STORAGE_PREFIX}encrypted`, encoded);
    localStorage.setItem(`${STORAGE_PREFIX}hash`, btoa(password));
    return true;
  } catch (error) {
    console.error('Save wallet error:', error);
    return false;
  }
};

export const loadWallet = (password) => {
  try {
    const encoded = localStorage.getItem(`${STORAGE_PREFIX}encrypted`);
    const hash = localStorage.getItem(`${STORAGE_PREFIX}hash`);
    
    if (!encoded || !hash) return null;
    if (btoa(password) !== hash) return null;
    
    const decoded = atob(encoded);
    const data = decoded.substring(0, decoded.length - password.length);
    const parsed = JSON.parse(data);
    
    return parsed.wallet;
  } catch (error) {
    console.error('Load wallet error:', error);
    return null;
  }
};

export const walletExists = () => {
  const hasDefault = !!localStorage.getItem(`${STORAGE_PREFIX}encrypted`);
  const walletList = getSavedWallets();
  return hasDefault || walletList.length > 0;
};

export const deleteWallet = () => {
  localStorage.removeItem(`${STORAGE_PREFIX}encrypted`);
  localStorage.removeItem(`${STORAGE_PREFIX}hash`);
};

// Multiple Wallets Management
export const saveWalletToList = (wallet, password, name) => {
  try {
    const wallets = getSavedWallets();
    
    // Check if wallet already exists
    const exists = wallets.find(w => w.address === wallet.address);
    if (exists) {
      return false; // Wallet already saved
    }
    
    const data = JSON.stringify({ wallet, timestamp: Date.now() });
    const encoded = btoa(data + password);
    
    const walletEntry = {
      id: Date.now().toString(),
      name: name,
      address: wallet.address,
      encrypted: encoded,
      hash: btoa(password),
      createdAt: new Date().toISOString()
    };
    
    wallets.push(walletEntry);
    localStorage.setItem(WALLETS_KEY, JSON.stringify(wallets));
    
    // Also save as default if no default exists
    if (!localStorage.getItem(`${STORAGE_PREFIX}encrypted`)) {
      saveWallet(wallet, password);
    }
    
    return true;
  } catch (error) {
    console.error('Save wallet to list error:', error);
    return false;
  }
};

export const getSavedWallets = () => {
  try {
    const data = localStorage.getItem(WALLETS_KEY);
    return data ? JSON.parse(data) : [];
  } catch {
    return [];
  }
};

export const loadWalletFromList = (walletId, password) => {
  try {
    const wallets = getSavedWallets();
    const walletEntry = wallets.find(w => w.id === walletId);
    
    if (!walletEntry) return null;
    if (btoa(password) !== walletEntry.hash) return null;
    
    const decoded = atob(walletEntry.encrypted);
    const data = decoded.substring(0, decoded.length - password.length);
    const parsed = JSON.parse(data);
    
    return parsed.wallet;
  } catch (error) {
    console.error('Load wallet from list error:', error);
    return null;
  }
};

export const removeWalletFromList = (walletId) => {
  try {
    const wallets = getSavedWallets();
    const filtered = wallets.filter(w => w.id !== walletId);
    localStorage.setItem(WALLETS_KEY, JSON.stringify(filtered));
    return true;
  } catch (error) {
    console.error('Remove wallet error:', error);
    return false;
  }
};

export const clearAllWallets = () => {
  try {
    localStorage.removeItem(WALLETS_KEY);
    return true;
  } catch (error) {
    console.error('Clear all wallets error:', error);
    return false;
  }
};

// Contact management
export const saveContact = (name, address, tag = '') => {
  try {
    const contacts = getContacts();
    const contact = { 
      id: Date.now().toString(), 
      name, 
      address, 
      tag: tag || '' 
    };
    contacts.push(contact);
    localStorage.setItem(`${STORAGE_PREFIX}contacts`, JSON.stringify(contacts));
    return contact;
  } catch (error) {
    console.error('Save contact error:', error);
    return null;
  }
};

export const getContacts = () => {
  try {
    const data = localStorage.getItem(`${STORAGE_PREFIX}contacts`);
    return data ? JSON.parse(data) : [];
  } catch {
    return [];
  }
};

export const deleteContact = (id) => {
  try {
    const contacts = getContacts().filter(c => c.id !== id && c.id !== parseInt(id));
    localStorage.setItem(`${STORAGE_PREFIX}contacts`, JSON.stringify(contacts));
    return true;
  } catch (error) {
    console.error('Delete contact error:', error);
    return false;
  }
};

// Settings management
export const saveSettings = (settings) => {
  try {
    localStorage.setItem(`${STORAGE_PREFIX}settings`, JSON.stringify(settings));
    return true;
  } catch (error) {
    console.error('Save settings error:', error);
    return false;
  }
};

export const loadSettings = () => {
  try {
    const data = localStorage.getItem(`${STORAGE_PREFIX}settings`);
    return data ? JSON.parse(data) : { network: 'testnet' };
  } catch {
    return { network: 'testnet' };
  }
};

// For backward compatibility
export const importWalletFromSeed = importWallet;
export const deleteStoredWallet = deleteWallet;
