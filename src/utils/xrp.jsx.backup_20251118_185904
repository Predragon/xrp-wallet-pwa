import { Client, Wallet, isValidClassicAddress } from 'xrpl';

// --- Configuration and Initialization ---

export const NETWORKS = {
    MAINNET: 'wss://s1.ripple.com/',
    TESTNET: 'wss://s.altnet.rippletest.net:51233/',
};

let currentNetwork = NETWORKS.TESTNET;
const XRP_EPOCH_OFFSET = 946684800; // Seconds between Unix Epoch and XRP Epoch (2000-01-01T00:00:00Z)

export const setNetwork = (network) => {
    currentNetwork = network;
};

export const getCurrentNetwork = () => {
    return currentNetwork;
};

// --- Wallet Management ---

// Use unique IDs for multi-wallet support
const WALLET_LIST_KEY = 'xrp_wallet_list_v2';

const getClient = () => {
    return new Client(currentNetwork);
};

export const generateWallet = () => {
    const wallet = Wallet.generate();
    return {
        address: wallet.classicAddress,
        secret: wallet.seed,
        name: 'New Wallet',
        id: crypto.randomUUID(),
    };
};

export const importWallet = (secret) => {
    const wallet = Wallet.fromSeed(secret);
    return {
        address: wallet.classicAddress,
        secret: wallet.seed,
        name: 'Imported Wallet',
        id: crypto.randomUUID(),
    };
};

export const isValidAddress = (address) => {
    return isValidClassicAddress(address);
};

// Storage functions use a simple encryption wrapper (base64 for simplicity in this context)
const encrypt = (data, password) => {
    // In a real application, use AES-256. Here, we use a simple base64/rot for demonstration
    return btoa(JSON.stringify(data) + '::' + password);
};

const decrypt = (encryptedText, password) => {
    try {
        const decoded = atob(encryptedText);
        const [data, storedPwd] = decoded.split('::');
        if (storedPwd === password) {
            return JSON.parse(data);
        }
        return null;
    } catch {
        return null;
    }
};

// --- Multi-Wallet Storage Functions ---

export const getSavedWallets = () => {
    try {
        const storedList = localStorage.getItem(WALLET_LIST_KEY);
        return storedList ? JSON.parse(storedList) : [];
    } catch (e) {
        console.error("Failed to load wallet list:", e);
        return [];
    }
};

export const saveWalletToList = (walletData, password, name) => {
    let walletList = getSavedWallets();
    
    // Check if wallet already exists
    if (walletList.some(w => w.id === walletData.id)) {
        // If it exists, update it (e.g., update name)
        walletList = walletList.filter(w => w.id !== walletData.id);
    }

    const walletToSave = { ...walletData, name: name };
    const encryptedData = encrypt(walletToSave, password);

    walletList.push({
        id: walletToSave.id,
        address: walletToSave.address,
        name: walletToSave.name,
        data: encryptedData,
    });

    localStorage.setItem(WALLET_LIST_KEY, JSON.stringify(walletList));
    return true;
};

export const loadWalletFromList = (walletId, password) => {
    const walletList = getSavedWallets();
    const walletInfo = walletList.find(w => w.id === walletId);

    if (walletInfo && walletInfo.data) {
        const decryptedWallet = decrypt(walletInfo.data, password);
        return decryptedWallet;
    }
    return null;
};

export const removeWalletFromList = (walletId) => {
    let walletList = getSavedWallets();
    const initialLength = walletList.length;
    walletList = walletList.filter(w => w.id !== walletId);
    
    localStorage.setItem(WALLET_LIST_KEY, JSON.stringify(walletList));
    return walletList.length !== initialLength;
};

export const clearAllWallets = () => {
    localStorage.removeItem(WALLET_LIST_KEY);
    // Also clear legacy single-wallet storage
    localStorage.removeItem('xrp_wallet_secret');
    localStorage.removeItem('xrp_wallet_address');
    return true;
};


// --- LEGACY Single Wallet Storage (for backward compatibility) ---
// Note: These functions are for handling the old format until migration is complete.

export const saveWallet = (wallet, password) => {
    const encryptedSecret = encrypt(wallet.secret, password);
    localStorage.setItem('xrp_wallet_secret', encryptedSecret);
    localStorage.setItem('xrp_wallet_address', wallet.address);
    return true;
};

export const loadWallet = (password) => {
    const encryptedSecret = localStorage.getItem('xrp_wallet_secret');
    const address = localStorage.getItem('xrp_wallet_address');
    
    if (encryptedSecret) {
        const decryptedSecret = decrypt(encryptedSecret, password);
        if (decryptedSecret) {
            return { secret: decryptedSecret, address: address };
        }
    }
    return null;
};

export const walletExists = () => {
    return localStorage.getItem('xrp_wallet_secret') !== null;
};

export const deleteWallet = () => {
    localStorage.removeItem('xrp_wallet_secret');
    localStorage.removeItem('xrp_wallet_address');
};

// --- Settings Storage ---

const SETTINGS_KEY = 'xrp_wallet_settings';

export const loadSettings = () => {
    try {
        const settings = localStorage.getItem(SETTINGS_KEY);
        return settings ? JSON.parse(settings) : { network: 'testnet' };
    } catch {
        return { network: 'testnet' };
    }
};

export const saveSettings = (settings) => {
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
};

// --- Contact Storage ---

const CONTACTS_KEY = 'xrp_wallet_contacts';

export const getContacts = () => {
    try {
        const contacts = localStorage.getItem(CONTACTS_KEY);
        return contacts ? JSON.parse(contacts) : [];
    } catch {
        return [];
    }
};

export const saveContact = (name, address, tag) => {
    const contacts = getContacts();
    const newContact = {
        id: Date.now(),
        name,
        address,
        tag: tag || null,
    };
    contacts.push(newContact);
    localStorage.setItem(CONTACTS_KEY, JSON.stringify(contacts));
    return newContact;
};

export const deleteContact = (id) => {
    const contacts = getContacts();
    const newContacts = contacts.filter(c => c.id !== id);
    localStorage.setItem(CONTACTS_KEY, JSON.stringify(newContacts));
};

// --- API Interactions ---

export const getBalance = async (address) => {
    const client = getClient();
    try {
        await client.connect();
        const response = await client.request({
            command: 'account_info',
            account: address,
            ledger_index: 'current',
        });
        const drops = response.result.account_data.Balance;
        return parseInt(drops) / 1000000;
    } catch (e) {
        // If account not found, return 0 instead of throwing
        if (e.message.includes('actNotFound')) {
            return 0;
        }
        throw new Error(`Failed to get balance: ${e.message}`);
    } finally {
        await client.disconnect();
    }
};

export const sendXRP = async (secret, recipient, amount, destinationTag = null) => {
    const client = getClient();
    try {
        await client.connect();
        const wallet = Wallet.fromSeed(secret);

        const prepared = await client.autofill({
            TransactionType: 'Payment',
            Account: wallet.classicAddress,
            Amount: String(Math.floor(amount * 1000000)), // Convert to drops
            Destination: recipient,
            ...(destinationTag && { DestinationTag: destinationTag }),
        });

        const signed = wallet.sign(prepared);
        const result = await client.submitAndWait(signed.tx_blob);

        if (result.result.engine_result === 'tesSUCCESS') {
            return {
                hash: result.result.tx_json.hash,
                result: 'Success',
            };
        } else {
            throw new Error(result.result.engine_result_message || 'Transaction failed');
        }
    } catch (e) {
        throw new Error(`Send failed: ${e.message}`);
    } finally {
        await client.disconnect();
    }
};

export const getXRPPrice = async () => {
    try {
        const response = await fetch(
            'https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd'
        );
        const data = await response.json();
        return data.ripple?.usd || 0.50; // Fallback to a reasonable estimate
    } catch (e) {
        console.warn('Could not fetch XRP price, using fallback value.');
        return 0.50; // Fallback value
    }
};

/**
 * Fetches and processes raw transaction history into a clean, standardized format.
 * @param {string} address - The XRP address to fetch history for.
 * @param {number} limit - The maximum number of transactions to fetch.
 * @returns {Promise<Array<Object>>} An array of clean transaction objects.
 */
export const getTransactionHistory = async (address, limit = 20) => {
    const client = getClient();
    try {
        await client.connect();
        
        const response = await client.request({
            command: 'account_tx',
            account: address,
            limit: limit,
        });

        // Map and clean the raw XRPL transaction data
        const cleanedTransactions = response.result.transactions
            .map(txData => {
                try {
                    const tx = txData.tx || txData.transaction; // The transaction object
                    const meta = txData.meta || txData.metadata; // The result metadata

                    if (!tx || !tx.TransactionType) {
                        return null; // Skip invalid or malformed entries
                    }

                    // 1. Direction and Type
                    const isSent = tx.Account === address;
                    const isReceived = tx.Destination === address && tx.TransactionType === 'Payment';
                    
                    // 2. Amount and Currency
                    let amount = '0.000000';
                    let currency = 'XRP';

                    if (tx.Amount) {
                        if (typeof tx.Amount === 'string') {
                            // XRP amount in drops (string)
                            amount = (parseInt(tx.Amount) / 1000000).toFixed(6);
                        } else if (typeof tx.Amount === 'object' && tx.Amount.value) {
                            // Non-XRP currency (object)
                            amount = parseFloat(tx.Amount.value).toFixed(6);
                            currency = tx.Amount.currency || 'Token';
                        }
                    }
                    
                    // 3. Date conversion (XRP time to JS time)
                    let dateString = 'Unknown date';
                    if (tx.date) {
                        const unixTimestamp = (tx.date + XRP_EPOCH_OFFSET) * 1000;
                        dateString = new Date(unixTimestamp).toLocaleString();
                    }

                    // 4. Success Status
                    const isSuccess = meta && (meta.TransactionResult === 'tesSUCCESS');

                    // 5. Build clean object
                    return {
                        txHash: tx.hash || tx.Hash || 'Unknown',
                        txType: tx.TransactionType,
                        isSent: isSent,
                        isReceived: isReceived,
                        amount: amount,
                        currency: currency,
                        date: dateString,
                        destinationTag: tx.DestinationTag || null,
                        isSuccess: isSuccess,
                        // rawTx: txData, // Keep this commented unless needed for debugging
                    };
                } catch (e) {
                    console.error('Error processing transaction data, skipping entry:', e, txData);
                    return null;
                }
            })
            .filter(Boolean); // Remove nulls (failed processing)

        return cleanedTransactions;

    } catch (e) {
        // Suppress 'actNotFound' error, but log others
        if (e.message.includes('actNotFound')) {
            return [];
        }
        throw new Error(`Failed to load transaction history: ${e.message}`);
    } finally {
        await client.disconnect();
    }
};


